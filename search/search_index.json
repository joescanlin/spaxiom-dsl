{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Spaxiom DSL","text":"<pre>\n                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\n                \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\n                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\n                \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\n                \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\n                \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d\n</pre> <p>Spaxiom is a powerful Domain-Specific Language (DSL) designed for building intelligent systems that work with:</p> <ul> <li>Spatial Data: Zones, sensors, and physical spaces</li> <li>Temporal Logic: Time-based conditions and historical analysis</li> <li>Event Processing: Triggering actions based on complex conditions</li> <li>Entity Management: Tracking and querying objects in your system</li> <li>Physical Units: Working with measurements in a type-safe manner</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<pre><code>     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557                   \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n     \u2551 SENSORS   \u2551                   \u2551 DETECTION \u2551\n     \u2551 \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2551\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2551\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf \u2551\n     \u2551 \u25cf\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2551\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2551\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u25cf \u2551\n     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d                   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n           \u2502                               \u25b2\n           \u25bc                               \u2502\n     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n     \u2551           \u2551     \u2551           \u2551     \u2551           \u2551\n     \u2551  SPATIAL  \u2551\u2550\u2550\u2550\u2550&gt;\u2551 TEMPORAL  \u2551\u2550\u2550\u2550\u2550&gt;\u2551   EVENTS  \u2551\n     \u2551           \u2551     \u2551           \u2551     \u2551           \u2551\n     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfe0 Spatial Zones: Define and work with 2D spatial regions</li> <li>\u26a1 Sensors: Interface with various sensor types and data streams</li> <li>\u23f1\ufe0f Temporal Logic: Create conditions that must be true for specific durations</li> <li>\ud83d\udd04 Event Callbacks: Register event handlers triggered by complex conditions</li> <li>\ud83d\udc65 Entity Tracking: Maintain collections of entities with flexible attributes</li> <li>\ud83d\udccf Physical Units: Work with measurements and conversions seamlessly</li> <li>\ud83e\udde9 Logical Operators: Combine conditions using intuitive &amp;, |, and ~ operators</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -e .\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from spaxiom import Sensor, Zone, Condition, on, within\n\n# Define a zone and sensor\noffice_zone = Zone(0, 0, 10, 10)\nmotion_sensor = Sensor(\"motion1\", \"motion\", (5, 5, 0))\n\n# Create condition based on sensor data\nmotion_detected = Condition(lambda: motion_sensor.read() &gt; 0.5)\n\n# Make it temporal - must be true for 5 seconds\nsustained_motion = within(5.0, motion_detected)\n\n# Register an event handler\n@on(sustained_motion)\ndef alert_sustained_motion():\n    print(\"Motion has been detected for 5 seconds!\")\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Quick Start Guide: Get up and running with Spaxiom</li> <li>API Reference: Detailed documentation of all Spaxiom components</li> <li>Temporal and Entity Operations: Working with time and entities</li> <li>CLI Usage: Using the command-line interface</li> <li>Examples: Real-world examples and use cases</li> </ul>"},{"location":"#license","title":"License","text":"<p>Spaxiom DSL is released under the MIT License. </p>"},{"location":"cli_usage/","title":"Spaxiom CLI Usage Guide","text":"<p>Spaxiom provides a command-line interface (CLI) for easily running Spaxiom DSL scripts. The CLI tool, <code>spax-run</code>, allows you to execute scripts that define sensors and event handlers without writing any additional runtime code.</p>"},{"location":"cli_usage/#installation","title":"Installation","text":"<p>The <code>spax-run</code> command is automatically installed when you install the Spaxiom package:</p> <pre><code>pip install spaxiom\n</code></pre>"},{"location":"cli_usage/#basic-usage","title":"Basic Usage","text":"<p>The basic syntax for the CLI is:</p> <pre><code>spax-run run &lt;script_path&gt; [options]\n</code></pre>"},{"location":"cli_usage/#options","title":"Options","text":"<ul> <li><code>--poll-ms</code>: Polling interval in milliseconds (default: 100)</li> <li><code>--history-length</code>: Maximum number of history entries to keep per condition (default: 1000)</li> <li><code>--config</code>: YAML configuration file for sensors and zones</li> <li><code>--verbose</code>: Enable verbose logging for detailed runtime information</li> </ul>"},{"location":"cli_usage/#creating-new-scripts","title":"Creating New Scripts","text":"<p>The CLI also provides a convenient command for generating new Spaxiom script scaffolds:</p> <pre><code>spax-run new &lt;script_name&gt; [options]\n</code></pre>"},{"location":"cli_usage/#options_1","title":"Options","text":"<ul> <li><code>--output-dir</code>: Directory where the scaffold script will be created (default: current directory)</li> <li><code>--sensors</code>: Number of sensor placeholders to include (default: 2)</li> <li><code>--zones</code>: Number of zone placeholders to include (default: 1)</li> <li><code>--privacy/--no-privacy</code>: Include privacy settings for sensors (default: enabled)</li> </ul>"},{"location":"cli_usage/#creating-a-demo-script","title":"Creating a Demo Script","text":"<p>To create a quick demo application:</p> <pre><code>spax-run new demo\n</code></pre> <p>This will generate a <code>demo.py</code> file in the current directory with: - 2 sensors (one with privacy settings) - 1 zone - A sample condition and event handler - A properly configured main function</p> <p>You can customize the script with more sensors and zones:</p> <pre><code>spax-run new complex_demo --sensors 5 --zones 3\n</code></pre> <p>Then, run your generated script with:</p> <pre><code>spax-run run demo.py\n</code></pre>"},{"location":"cli_usage/#examples","title":"Examples","text":""},{"location":"cli_usage/#running-the-occupancy-demo","title":"Running the Occupancy Demo","text":"<p>The occupancy demo (<code>examples/occupancy_demo.py</code>) demonstrates how to create multiple sensor types and define zones for occupancy detection.</p> <p>To run the demo:</p> <pre><code>spax-run run examples/occupancy_demo.py\n</code></pre> <p>Example output:</p> <pre><code>Importing /path/to/examples/occupancy_demo.py...\nScript has a main() function. Executing it directly.\n\nSpaxiom Occupancy Detection Demo\n--------------------------------\nZone A: Zone(x1=0, y1=0, x2=10, y2=10)\nZone B: Zone(x1=15, y1=0, x2=25, y2=10)\n\nSetting up sensors in zones A and B...\nSensors initialized:\n  OccupancySensor(name=pressure_A, location=(5, 5, 0), sensor_type=pressure)\n  OccupancySensor(name=thermal_A, location=(5, 5, 0), sensor_type=thermal)\n  OccupancySensor(name=pressure_B, location=(20, 5, 0), sensor_type=pressure)\n\nStarting occupancy monitoring...\nThe message '** ZONE A OCCUPIED **' will appear when:\n  1. Pressure is detected in Zone A\n  2. Thermal signature is detected in Zone A\n  3. No pressure is detected in Zone B\n  4. These conditions remain true for at least 1 second\n\nPress Ctrl+C to exit\n\nPressure A: ON | Thermal A: ON | Pressure B: off | Occupancy Condition: TRUE\n** ZONE A OCCUPIED **\nPressure A: ON | Thermal A: ON | Pressure B: off | Occupancy Condition: TRUE\nPressure A: off | Thermal A: ON | Pressure B: ON | Occupancy Condition: false\nPressure A: ON | Thermal A: ON | Pressure B: off | Occupancy Condition: TRUE\n** ZONE A OCCUPIED **\n</code></pre>"},{"location":"cli_usage/#running-the-sequence-demo","title":"Running the Sequence Demo","text":"<p>The sequence demo demonstrates how to detect a temporal sequence of events:</p> <pre><code>spax-run run examples/sequence_demo.py --poll-ms 50\n</code></pre> <p>Example output:</p> <pre><code>Importing /path/to/examples/sequence_demo.py...\nScript has a main() function. Executing it directly.\nDetected async main function. Running with asyncio.\n\nSequence Pattern Example: Door \u2192 Person \u2192 Door Close\n----------------------------------------------------\nThis example detects the sequence: door open \u2192 person present \u2192 door close\nWhen the pattern is detected within 10 seconds, it prints 'Entry detected'\nDoor front_door CLOSED at t=1685432017.81\nPerson no longer detected by entry_area\n\nStarting runtime and waiting for events...\n\n[Spaxiom] Runtime started with poll interval of 50ms\n\nSimulating sequence: door open \u2192 person detected \u2192 door closed\nDoor front_door OPENED at t=1685432018.81\nPERSON DETECTED by entry_area at t=1685432020.81\nDoor front_door CLOSED at t=1685432022.81\n\nWaiting for sequence detection...\nSequence successfully detected!\n\nDemo complete.\n</code></pre>"},{"location":"cli_usage/#customizing-polling-rate","title":"Customizing Polling Rate","text":"<p>For more responsive monitoring, you can decrease the polling interval:</p> <pre><code>spax-run run examples/occupancy_demo.py --poll-ms 50\n</code></pre> <p>This will make the runtime check sensor values more frequently (every 50ms instead of the default 100ms).</p>"},{"location":"cli_usage/#managing-history-length","title":"Managing History Length","text":"<p>For memory-sensitive applications or when you need to track longer histories:</p> <pre><code>spax-run run examples/sequence_demo.py --history-length 2000\n</code></pre> <p>This increases the maximum number of historical states kept for each condition from the default 1000 to 2000.</p>"},{"location":"cli_usage/#enabling-verbose-logging","title":"Enabling Verbose Logging","text":"<p>For troubleshooting or development, you can enable verbose logging:</p> <pre><code>spax-run run examples/sequence_demo.py --verbose\n</code></pre> <p>With verbose logging enabled, you'll see detailed information about: - Sensor readings and updates - Condition evaluations - Plugin loading - Internal runtime events - Debugging information</p> <p>This is particularly useful when developing custom sensors or troubleshooting complex conditions.</p>"},{"location":"cli_usage/#getting-help","title":"Getting Help","text":"<p>To view available commands and options:</p> <pre><code>spax-run --help\n</code></pre> <p>For help on a specific command:</p> <pre><code>spax-run run --help\n</code></pre>"},{"location":"cli_usage/#advanced-usage","title":"Advanced Usage","text":"<p>The CLI detects whether your script has a <code>main()</code> function:</p> <ol> <li>If a <code>main()</code> function is present, it will be executed directly.</li> <li>If the <code>main()</code> function is asynchronous (an async function), it will be run with <code>asyncio.run()</code>.</li> <li>If no <code>main()</code> function is found, the Spaxiom runtime will be started automatically to process any registered sensors and event handlers. </li> </ol>"},{"location":"quickstart/","title":"Spaxiom DSL Quick Start Guide","text":"<p>This guide will help you get started with Spaxiom DSL, a Python library for spatial sensor fusion and AI.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>You can install Spaxiom directly from the repository:</p> <pre><code># Clone the repository\ngit clone https://github.com/username/spaxiom-dsl.git\ncd spaxiom-dsl\n\n# Install in development mode\npip install -e .\n\n# To install with development dependencies\npip install -e .[dev]\n</code></pre>"},{"location":"quickstart/#hello-runtime-example","title":"Hello Runtime Example","text":"<p>Create a file named <code>hello_runtime.py</code> with the following code:</p> <pre><code>from spaxiom import Sensor, Zone, Condition, on\nfrom spaxiom.sensor import RandomSensor\nfrom spaxiom.runtime import start_blocking\nimport time\n\n# Create a random sensor at location (0, 0, 0)\nrs = RandomSensor('random1', location=(0.0, 0.0, 0.0))\n\n# Define a zone for detection\ndetection_zone = Zone(0.0, 0.0, 1.0, 1.0)\n\n# Define conditions\nhigh_value = Condition(lambda: rs.read() &gt; 0.7)\nin_zone = Condition(lambda: detection_zone.contains((rs.read(), rs.read())))\n\n# Register event handlers\n@on(high_value)\ndef alert_high_value():\n    print(f\"HIGH VALUE DETECTED: {rs.read():.3f}\")\n\n@on(in_zone)\ndef alert_in_zone():\n    print(f\"POINT IN ZONE: ({rs.read():.3f}, {rs.read():.3f})\")\n\n@on(high_value &amp; in_zone)\ndef alert_high_in_zone():\n    print(\"HIGH VALUE AND IN ZONE!\")\n\n# Start the runtime with a 500ms polling interval\nif __name__ == \"__main__\":\n    print(\"Starting Spaxiom Runtime...\")\n    print(\"Press Ctrl+C to exit\")\n    start_blocking(poll_ms=500)\n</code></pre>"},{"location":"quickstart/#running-the-example","title":"Running the Example","text":"<p>Run the example with:</p> <pre><code>python hello_runtime.py\n</code></pre>"},{"location":"quickstart/#example-output","title":"Example Output","text":"<p>When you run the example, you'll see output similar to this:</p> <pre><code>Starting Spaxiom Runtime...\nPress Ctrl+C to exit\n[Spaxiom] Runtime started with poll interval of 500ms\n[Spaxiom] Fired alert_high_value\nHIGH VALUE DETECTED: 0.781\n[Spaxiom] Fired alert_in_zone\nPOINT IN ZONE: (0.345, 0.567)\n[Spaxiom] Fired alert_high_value\nHIGH VALUE DETECTED: 0.892\n[Spaxiom] Fired alert_high_in_zone\nHIGH VALUE AND IN ZONE!\n[Spaxiom] Fired alert_in_zone\nPOINT IN ZONE: (0.456, 0.234)\n[Spaxiom] Fired alert_high_value\nHIGH VALUE DETECTED: 0.723\n^C\n[Spaxiom] Runtime stopped by user\n</code></pre> <p>The output shows: 1. The runtime starting with a 500ms polling interval 2. Event handlers being triggered when their conditions are met 3. The runtime stopping when you press Ctrl+C</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Specification for more details on the DSL syntax</li> <li>Explore the examples in the <code>examples/</code> directory</li> <li>Read the API documentation for more advanced usage </li> </ul>"},{"location":"quickstart/#creating-a-custom-plugin","title":"Creating a Custom Plugin","text":"<p>Spaxiom supports extending its functionality through plugins. This example shows how to create a custom CO2 sensor plugin.</p>"},{"location":"quickstart/#creating-a-co2sensor-plugin","title":"Creating a CO2Sensor Plugin","text":"<p>Create a file named <code>co2_plugin.py</code> with the following code:</p> <pre><code>import random\nimport time\nfrom typing import Optional, Dict, Any, Tuple\n\nfrom spaxiom import register_plugin, Sensor\n\nclass CO2Sensor(Sensor):\n    \"\"\"\n    A custom CO2 sensor that simulates carbon dioxide readings in parts per million (ppm).\n\n    Features:\n    - Baseline CO2 level with random fluctuations\n    - Configurable sensor sensitivity and range\n    - Simulates real-world CO2 concentration patterns\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        location: Tuple[float, float, float],\n        baseline_ppm: float = 400.0,  # Typical outdoor CO2 level\n        fluctuation: float = 50.0,    # Amount of random fluctuation\n        max_ppm: float = 2000.0,      # Maximum possible reading\n        hz: float = 1.0,              # Polling frequency\n        privacy: str = \"public\",\n        metadata: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"Initialize the CO2 sensor with the given parameters.\"\"\"\n        # Calculate sample period from frequency\n        sample_period = 1.0 / hz if hz &gt; 0 else 0.0\n\n        # Set up metadata if not provided\n        if metadata is None:\n            metadata = {}\n        metadata.update({\"unit\": \"ppm\", \"type\": \"carbon_dioxide\"})\n\n        super().__init__(\n            name=name,\n            sensor_type=\"co2\",\n            location=location,\n            privacy=privacy,\n            sample_period_s=sample_period,\n            metadata=metadata,\n        )\n\n        self.baseline_ppm = baseline_ppm\n        self.fluctuation = fluctuation\n        self.max_ppm = max_ppm\n        self.last_reading_time = time.time()\n        self.current_value = baseline_ppm\n\n    def _read_raw(self) -&gt; float:\n        \"\"\"\n        Generate a simulated CO2 reading in parts per million (ppm).\n\n        Returns:\n            A CO2 concentration value in ppm\n        \"\"\"\n        now = time.time()\n        time_diff = now - self.last_reading_time\n        self.last_reading_time = now\n\n        # Simulate CO2 fluctuations\n        drift = random.uniform(-self.fluctuation, self.fluctuation) * time_diff\n        self.current_value += drift\n\n        # Ensure values stay within reasonable bounds\n        self.current_value = max(300.0, min(self.current_value, self.max_ppm))\n\n        return self.current_value\n\n    def is_high(self, threshold: float = 1000.0) -&gt; bool:\n        \"\"\"\n        Check if CO2 levels are above a threshold.\n\n        Args:\n            threshold: The CO2 concentration threshold in ppm\n\n        Returns:\n            True if current CO2 level exceeds the threshold\n        \"\"\"\n        return self.read() &gt; threshold\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the CO2 sensor.\"\"\"\n        return f\"CO2Sensor(name='{self.name}', location={self.location}, baseline={self.baseline_ppm}ppm)\"\n\n\n@register_plugin\ndef setup_co2_sensors():\n    \"\"\"\n    Register the CO2 sensor type with Spaxiom.\n\n    This function is decorated with @register_plugin, which means it will be \n    automatically called when the Spaxiom runtime starts.\n    \"\"\"\n    print(\"[Plugin] Registering CO2Sensor plugin\")\n\n    # Create a demonstration CO2 sensor\n    CO2Sensor(\n        name=\"living_room_co2\",\n        location=(1.0, 2.0, 0.0),\n        baseline_ppm=450.0,  # Slightly elevated indoor level\n        hz=2.0,\n        metadata={\"room\": \"living_room\"},\n    )\n\n    # Create another CO2 sensor with different parameters\n    CO2Sensor(\n        name=\"bedroom_co2\",\n        location=(5.0, 3.0, 0.0),\n        baseline_ppm=420.0,\n        fluctuation=30.0,\n        hz=1.0,\n        metadata={\"room\": \"bedroom\"},\n    )\n\n    print(\"[Plugin] CO2Sensor plugin registered with 2 sensors\")\n</code></pre>"},{"location":"quickstart/#using-the-co2sensor-plugin","title":"Using the CO2Sensor Plugin","text":"<p>Create a file named <code>co2_monitor.py</code> to use the plugin:</p> <pre><code>from spaxiom import Condition, on, within, SensorRegistry\nfrom spaxiom.runtime import start_blocking\nimport importlib\n\ndef main():\n    \"\"\"Run the CO2 monitoring application.\"\"\"\n    print(\"\\nCO2 Monitoring with Spaxiom\")\n    print(\"===========================\")\n\n    # Manually import the plugin \n    # (Alternative: place it in the spaxiom_site_plugins package for auto-loading)\n    importlib.import_module(\"co2_plugin\")\n\n    # Get the registry to access the CO2 sensors\n    registry = SensorRegistry()\n\n    try:\n        # Get the CO2 sensors\n        living_room_co2 = registry.get(\"living_room_co2\")\n        bedroom_co2 = registry.get(\"bedroom_co2\")\n\n        print(f\"\\nDetected CO2 sensors:\")\n        print(f\"  - {living_room_co2}\")\n        print(f\"  - {bedroom_co2}\")\n\n        # Define CO2 level conditions\n        living_room_high = Condition(lambda: living_room_co2.read() &gt; 800)\n        bedroom_high = Condition(lambda: bedroom_co2.read() &gt; 800)\n\n        # Define sustained conditions\n        sustained_high_living = within(10.0, living_room_high)\n        sustained_high_bedroom = within(10.0, bedroom_high)\n\n        # Define a condition for when both rooms have high CO2\n        all_rooms_high = living_room_high &amp; bedroom_high\n\n        # Register event handlers\n        @on(living_room_high)\n        def on_living_room_high():\n            value = living_room_co2.read()\n            print(f\"[Alert] Living room CO2 level high: {value:.0f} ppm\")\n\n        @on(bedroom_high)\n        def on_bedroom_high():\n            value = bedroom_co2.read()\n            print(f\"[Alert] Bedroom CO2 level high: {value:.0f} ppm\")\n\n        @on(all_rooms_high)\n        def on_all_rooms_high():\n            living = living_room_co2.read()\n            bed = bedroom_co2.read()\n            print(f\"[Alert] All rooms have high CO2 levels! Living: {living:.0f} ppm, Bedroom: {bed:.0f} ppm\")\n            print(f\"        You should open some windows for ventilation!\")\n\n        @on(sustained_high_living)\n        def on_sustained_living_room_high():\n            value = living_room_co2.read()\n            print(f\"[Warning] Living room CO2 has been high ({value:.0f} ppm) for over 10 seconds!\")\n\n        print(\"\\nCO2 monitoring active. Press Ctrl+C to exit...\\n\")\n\n        # Start the Spaxiom runtime - this will automatically poll the sensors\n        # and trigger the event handlers when conditions are met\n        start_blocking(poll_ms=500)\n\n    except KeyError as e:\n        print(f\"\\nError: Could not find CO2 sensor: {e}\")\n        print(\"Make sure the plugin was properly loaded.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"quickstart/#running-the-co2-monitoring-example","title":"Running the CO2 Monitoring Example","text":"<p>Run the example with:</p> <pre><code>python co2_monitor.py\n</code></pre> <p>You'll see output similar to this:</p> <pre><code>CO2 Monitoring with Spaxiom\n===========================\n[Plugin] Registering CO2Sensor plugin\n[Plugin] CO2Sensor plugin registered with 2 sensors\n\nDetected CO2 sensors:\n  - CO2Sensor(name='living_room_co2', location=(1.0, 2.0, 0.0), baseline=450.0ppm)\n  - CO2Sensor(name='bedroom_co2', location=(5.0, 3.0, 0.0), baseline=420.0ppm)\n\nCO2 monitoring active. Press Ctrl+C to exit...\n\n[Spaxiom] Runtime started with 2 sensor polling tasks\n[Spaxiom] Press Ctrl+C to stop\n[Alert] Living room CO2 level high: 803 ppm\n[Alert] Bedroom CO2 level high: 832 ppm\n[Alert] All rooms have high CO2 levels! Living: 803 ppm, Bedroom: 832 ppm\n        You should open some windows for ventilation!\n[Warning] Living room CO2 has been high (875 ppm) for over 10 seconds!\n^C\n[Spaxiom] Shutdown initiated, cancelling tasks...\n[Spaxiom] Shutdown complete.\n</code></pre> <p>This demonstrates how Spaxiom's plugin system allows you to extend the DSL with custom sensors and functionality. </p>"},{"location":"release_checklist/","title":"Spaxiom Release Checklist","text":"<p>This document outlines the steps required to release a new version of the Spaxiom DSL package.</p>"},{"location":"release_checklist/#release-process","title":"Release Process","text":""},{"location":"release_checklist/#1-prepare-the-release","title":"1. Prepare the Release","text":"<ul> <li> <p>[ ] Make sure all tests pass locally   <pre><code>python -m pytest\n</code></pre></p> </li> <li> <p>[ ] Check code quality with linters   <pre><code>black --check .\nruff check .\n</code></pre></p> </li> <li> <p>[ ] Update CHANGELOG.md (if present) with changes since the last release</p> </li> </ul>"},{"location":"release_checklist/#2-bump-version-numbers","title":"2. Bump Version Numbers","text":"<ul> <li> <p>[ ] Update version in <code>pyproject.toml</code>:   <pre><code>[tool.poetry]\nname = \"spaxiom\"\nversion = \"X.Y.Z\"  # Update this line\n</code></pre></p> </li> <li> <p>[ ] Update version in <code>spaxiom/__init__.py</code>:   <pre><code>__version__ = \"X.Y.Z\"  # Update this line\n</code></pre></p> </li> <li> <p>[ ] Install the package locally to verify the version change:   <pre><code>pip install -e .\npython -c \"import spaxiom; print(spaxiom.__version__)\"\n</code></pre></p> </li> </ul>"},{"location":"release_checklist/#3-commit-and-tag-the-release","title":"3. Commit and Tag the Release","text":"<ul> <li> <p>[ ] Commit the version change:   <pre><code>git add pyproject.toml spaxiom/__init__.py\ngit commit -m \"Bump version to X.Y.Z\"\n</code></pre></p> </li> <li> <p>[ ] Create a release tag:   <pre><code>git tag -a vX.Y.Z -m \"Version X.Y.Z\"\n</code></pre></p> </li> <li> <p>[ ] Push the commit and tag:   <pre><code>git push\ngit push origin vX.Y.Z\n</code></pre></p> </li> </ul>"},{"location":"release_checklist/#4-verify-the-build-and-deployment","title":"4. Verify the Build and Deployment","text":"<ul> <li>[ ] Check GitHub Actions to verify the CI workflow is running</li> <li>Go to your repository's Actions tab in GitHub</li> <li> <p>Check that the workflow triggered by the tag is running</p> </li> <li> <p>[ ] Verify the package was uploaded to TestPyPI</p> </li> <li>Visit https://test.pypi.org/project/spaxiom/</li> <li>Check that the new version is listed</li> </ul>"},{"location":"release_checklist/#5-test-installation-from-testpypi","title":"5. Test Installation from TestPyPI","text":"<ul> <li> <p>[ ] Create a new virtual environment:   <pre><code>python -m venv test_install\nsource test_install/bin/activate  # On Unix/macOS\n# or\ntest_install\\Scripts\\activate  # On Windows\n</code></pre></p> </li> <li> <p>[ ] Install the package from TestPyPI:   <pre><code>pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ spaxiom==X.Y.Z\n</code></pre></p> </li> <li> <p>[ ] Verify the installation:   <pre><code>python -c \"import spaxiom; print(spaxiom.__version__)\"\nspax-run --help\n</code></pre></p> </li> </ul>"},{"location":"release_checklist/#6-final-release-to-pypi-if-applicable","title":"6. Final Release to PyPI (if applicable)","text":"<p>If you're ready to release to the main PyPI repository, update your CI configuration to also deploy to PyPI or manually publish:</p> <ul> <li>[ ] Deploy to PyPI:   <pre><code>pip install twine\ntwine upload dist/*\n</code></pre></li> </ul>"},{"location":"release_checklist/#7-post-release","title":"7. Post-Release","text":"<ul> <li>[ ] Create a GitHub Release:</li> <li>Go to Releases \u2192 Draft a new release</li> <li>Choose the tag you created</li> <li> <p>Add release notes</p> </li> <li> <p>[ ] Bump version to next development version (optional):</p> </li> <li>Update version to \"X.Y.(Z+1)-dev\" in pyproject.toml and init.py</li> <li>Commit: <code>git commit -m \"Bump to development version X.Y.(Z+1)-dev\"</code></li> </ul>"},{"location":"release_checklist/#notes","title":"Notes","text":"<ul> <li>The CI workflow will automatically build and deploy the package to TestPyPI when a tag starting with \"v\" is pushed.</li> <li>Make sure the <code>TEST_PYPI_TOKEN</code> secret is configured in your GitHub repository settings.</li> <li>For proper semantic versioning:</li> <li>Bump major version (X) for incompatible API changes</li> <li>Bump minor version (Y) for new functionality in a backward-compatible manner</li> <li>Bump patch version (Z) for backward-compatible bug fixes </li> </ul>"},{"location":"spec/","title":"Spaxiom DSL Formal Specification","text":""},{"location":"spec/#overview","title":"Overview","text":"<p>Spaxiom is an embedded domain-specific language (DSL) for spatial sensor fusion and temporal reasoning, implemented in Python. This document provides a formal grammar specification for the DSL, focusing on the key components and their composition rules.</p>"},{"location":"spec/#bnf-grammar-specification","title":"BNF Grammar Specification","text":"<p>The following Backus-Naur Form (BNF) grammar defines the core constructs of the Spaxiom DSL:</p> <pre><code>&lt;spaxiom-program&gt; ::= &lt;import-statements&gt; &lt;declaration-list&gt; [&lt;main-function&gt;]\n\n&lt;import-statements&gt; ::= \"from spaxiom import\" &lt;import-list&gt;\n&lt;import-list&gt; ::= &lt;import-item&gt; [\",\" &lt;import-item&gt;]*\n&lt;import-item&gt; ::= &lt;identifier&gt;\n\n&lt;declaration-list&gt; ::= &lt;declaration&gt;+\n&lt;declaration&gt; ::= &lt;sensor-decl&gt; | &lt;zone-decl&gt; | &lt;condition-decl&gt; | &lt;event-handler-decl&gt; | &lt;entity-set-decl&gt;\n\n&lt;sensor-decl&gt; ::= &lt;identifier&gt; \"=\" &lt;sensor-type&gt; \"(\" &lt;sensor-args&gt; \")\"\n&lt;sensor-type&gt; ::= \"Sensor\" | \"RandomSensor\" | \"TogglingSensor\" | \"GPIOSensor\" | &lt;custom-sensor&gt;\n&lt;sensor-args&gt; ::= \"name=\" &lt;string&gt; \",\" \"sensor_type=\" &lt;string&gt; \",\" \"location=\" &lt;coordinate&gt; [\",\" &lt;sensor-option&gt;]*\n&lt;sensor-option&gt; ::= \"privacy=\" &lt;privacy-value&gt; | \"sample_period_s=\" &lt;number&gt; | \"metadata=\" &lt;dict&gt;\n&lt;privacy-value&gt; ::= '\"public\"' | '\"private\"'\n&lt;coordinate&gt; ::= \"(\" &lt;number&gt; \",\" &lt;number&gt; \",\" &lt;number&gt; \")\"\n\n&lt;zone-decl&gt; ::= &lt;identifier&gt; \"=\" \"Zone\" \"(\" &lt;number&gt; \",\" &lt;number&gt; \",\" &lt;number&gt; \",\" &lt;number&gt; \")\"\n\n&lt;condition-decl&gt; ::= &lt;identifier&gt; \"=\" &lt;condition-expr&gt;\n&lt;condition-expr&gt; ::= &lt;simple-condition&gt; | &lt;combined-condition&gt; | &lt;temporal-condition&gt;\n&lt;simple-condition&gt; ::= \"Condition\" \"(\" &lt;lambda-function&gt; \")\"\n&lt;combined-condition&gt; ::= &lt;condition-expr&gt; &lt;operator&gt; &lt;condition-expr&gt; | \"~\" &lt;condition-expr&gt;\n&lt;operator&gt; ::= \"&amp;\" | \"|\"\n&lt;temporal-condition&gt; ::= \"within\" \"(\" &lt;number&gt; \",\" &lt;condition-expr&gt; \")\" | \"sequence\" \"(\" &lt;condition-list&gt; \",\" &lt;number&gt; \")\"\n&lt;condition-list&gt; ::= \"[\" &lt;condition-expr&gt; [\",\" &lt;condition-expr&gt;]* \"]\"\n&lt;lambda-function&gt; ::= \"lambda\" [\":\" &lt;python-expression&gt;]\n\n&lt;entity-set-decl&gt; ::= &lt;identifier&gt; \"=\" \"EntitySet\" \"(\" &lt;string&gt; \")\"\n\n&lt;event-handler-decl&gt; ::= \"@on\" \"(\" &lt;condition-expr&gt; \")\" &lt;newline&gt; \"def\" &lt;identifier&gt; \"(\" \")\" \":\" &lt;newline&gt; &lt;handler-body&gt;\n&lt;handler-body&gt; ::= &lt;python-statement&gt;+\n\n&lt;main-function&gt; ::= \"def main():\" &lt;newline&gt; &lt;python-statement&gt;+\n\n&lt;python-statement&gt; ::= &lt;valid-python-code&gt;\n&lt;python-expression&gt; ::= &lt;valid-python-expression&gt;\n&lt;dict&gt; ::= \"{\" [&lt;key-value-pair&gt; [\",\" &lt;key-value-pair&gt;]*] \"}\"\n&lt;key-value-pair&gt; ::= &lt;string&gt; \":\" &lt;value&gt;\n&lt;value&gt; ::= &lt;string&gt; | &lt;number&gt; | &lt;dict&gt; | &lt;list&gt;\n&lt;list&gt; ::= \"[\" [&lt;value&gt; [\",\" &lt;value&gt;]*] \"]\"\n&lt;string&gt; ::= '\"' &lt;characters&gt; '\"' | \"'\" &lt;characters&gt; \"'\"\n&lt;number&gt; ::= &lt;integer&gt; | &lt;float&gt;\n&lt;integer&gt; ::= &lt;digit&gt;+\n&lt;float&gt; ::= &lt;digit&gt;+ \".\" &lt;digit&gt;*\n&lt;digit&gt; ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n&lt;identifier&gt; ::= &lt;letter&gt; [&lt;letter&gt; | &lt;digit&gt; | \"_\"]*\n&lt;letter&gt; ::= \"A\" | \"B\" | ... | \"Z\" | \"a\" | \"b\" | ... | \"z\"\n&lt;newline&gt; ::= \"\\n\"\n&lt;characters&gt; ::= &lt;character&gt;*\n&lt;character&gt; ::= &lt;any-valid-character&gt;\n&lt;custom-sensor&gt; ::= &lt;identifier&gt;\n</code></pre>"},{"location":"spec/#operator-precedence","title":"Operator Precedence","text":"<p>The Spaxiom DSL adopts standard logical operator precedence for conditions, which are implemented using Python's operator overloading mechanism. The precedence order from highest to lowest is:</p> <ol> <li><code>~</code> (NOT) - Unary operator with highest precedence</li> <li><code>&amp;</code> (AND) - Binary operator with medium precedence</li> <li><code>|</code> (OR) - Binary operator with lowest precedence</li> </ol> <p>This means that expressions are evaluated in the following order:</p> <pre><code>~A &amp; B | C\n</code></pre> <p>is equivalent to:</p> <pre><code>((~A) &amp; B) | C\n</code></pre>"},{"location":"spec/#precedence-rules","title":"Precedence Rules","text":"<p>The precedence of operators in the Spaxiom DSL follows these rules:</p> <ol> <li>Negation (<code>~</code>) has the highest precedence:</li> <li>When you negate a condition using <code>~</code>, this is always applied first.</li> <li> <p>Example: <code>~condition1 &amp; condition2</code> is interpreted as <code>(~condition1) &amp; condition2</code>.</p> </li> <li> <p>Conjunction (<code>&amp;</code>) has higher precedence than disjunction:</p> </li> <li>The AND operator is applied before the OR operator.</li> <li> <p>Example: <code>condition1 &amp; condition2 | condition3</code> is interpreted as <code>(condition1 &amp; condition2) | condition3</code>.</p> </li> <li> <p>Disjunction (<code>|</code>) has the lowest precedence:</p> </li> <li>The OR operator is applied last in a complex expression.</li> <li> <p>Example: <code>condition1 | condition2 &amp; condition3</code> is interpreted as <code>condition1 | (condition2 &amp; condition3)</code>.</p> </li> <li> <p>Parentheses can be used to override default precedence:</p> </li> <li>For clarity or to change the order of operations, use parentheses.</li> <li>Example: <code>condition1 | (condition2 &amp; ~condition3)</code>.</li> </ol>"},{"location":"spec/#implementation-details","title":"Implementation Details","text":"<p>These precedence rules are implemented in the <code>Condition</code> class through the following methods:</p> <pre><code>def __and__(self, other: \"Condition\") -&gt; \"Condition\":\n    \"\"\"Implement the &amp; operator (logical AND).\"\"\"\n    def combined_condition(**kwargs):\n        # Short-circuit evaluation\n        if not self(**kwargs):\n            return False\n        return other(**kwargs)\n    return Condition(combined_condition)\n\ndef __or__(self, other: \"Condition\") -&gt; \"Condition\":\n    \"\"\"Implement the | operator (logical OR).\"\"\"\n    def combined_condition(**kwargs):\n        # Short-circuit evaluation\n        if self(**kwargs):\n            return True\n        return other(**kwargs)\n    return Condition(combined_condition)\n\ndef __invert__(self) -&gt; \"Condition\":\n    \"\"\"Implement the ~ operator (logical NOT).\"\"\"\n    def inverted_condition(**kwargs):\n        return not self(**kwargs)\n    return Condition(inverted_condition)\n</code></pre>"},{"location":"spec/#examples","title":"Examples","text":"<p>Here are some examples of how to use logical operators in Spaxiom with their evaluation order:</p> <pre><code># Individual conditions\nin_zone = Condition(lambda: zone.contains(sensor.location))\nis_hot = Condition(lambda: temperature.read() &gt; 30.0)\nis_moving = Condition(lambda: motion.read() &gt; 0.5)\n\n# Combined conditions with operator precedence\n\n# 1. Simple AND: Both conditions must be true\nin_hot_zone = in_zone &amp; is_hot  # Evaluates: in_zone AND is_hot\n\n# 2. Simple OR: Either condition can be true \nalert_condition = in_zone | is_hot  # Evaluates: in_zone OR is_hot\n\n# 3. NOT applied to a single condition\nnot_in_zone = ~in_zone  # Evaluates: NOT in_zone\n\n# 4. Complex expression with all operators\ncomplex_condition = ~is_hot &amp; in_zone | is_moving\n# Evaluates as: ((NOT is_hot) AND in_zone) OR is_moving\n\n# 5. Using parentheses to override precedence\noverride_precedence = ~(is_hot &amp; in_zone) | is_moving\n# Evaluates as: (NOT (is_hot AND in_zone)) OR is_moving\n\n# 6. Another example with parentheses\nanother_override = is_hot &amp; (in_zone | is_moving)\n# Evaluates as: is_hot AND (in_zone OR is_moving)\n</code></pre>"},{"location":"spec/#temporal-operators","title":"Temporal Operators","text":"<p>The temporal operators like <code>within</code> and <code>sequence</code> have their own precedence rules, and they typically operate on condition expressions:</p> <pre><code># Condition must be true for at least 5 seconds\nsustained_condition = within(5.0, is_hot &amp; in_zone)\n\n# Sequence of conditions must happen in order within 10 seconds\nentry_sequence = sequence([door_open, person_detected, door_closed], 10.0)\n</code></pre> <p>These temporal operators wrap condition expressions and create new condition objects that can be further combined with the logical operators described above. </p>"},{"location":"spec_draft/","title":"Spaxiom DSL Specification Draft","text":""},{"location":"spec_draft/#overview","title":"Overview","text":"<p>Spaxiom is an embedded domain-specific language (DSL) for spatial sensor fusion and AI, implemented in Python. It provides a concise syntax for defining sensors, zones, conditions, and event handlers.</p>"},{"location":"spec_draft/#core-components","title":"Core Components","text":""},{"location":"spec_draft/#sensors","title":"Sensors","text":"<p>Sensors represent data sources in physical space.</p> <pre><code># Define a sensor with name, type, and location\nlidar = Sensor(name=\"front_lidar\", sensor_type=\"lidar\", location=(0.0, 0.0, 1.5))\n\n# Custom sensor types can extend the base Sensor class\ntemp_sensor = TemperatureSensor(name=\"cabin_temp\", location=(1.0, 0.5, 1.2))\n</code></pre>"},{"location":"spec_draft/#zones","title":"Zones","text":"<p>Zones define spatial areas for event triggering.</p> <pre><code># Define a rectangular zone with corners (x1, y1) and (x2, y2)\nentry_zone = Zone(0.0, 0.0, 5.0, 5.0)\n\n# Check if a point is within a zone\nis_inside = entry_zone.contains((2.5, 3.0))\nis_inside = entry_zone.contains(Point(2.5, 3.0))\n</code></pre>"},{"location":"spec_draft/#conditions","title":"Conditions","text":"<p>Conditions are boolean expressions that can be combined using logical operators.</p> <pre><code># Simple condition\nis_hot = Condition(lambda: temp_sensor.read() &gt; 30.0)\n\n# Sensor in zone condition\nin_zone = Condition(lambda: entry_zone.contains(vehicle_sensor.location))\n\n# Combine conditions with logical operators\nis_actionable = is_hot &amp; in_zone  # AND\nis_alert = is_hot | in_zone       # OR\nis_normal = ~is_hot               # NOT\n</code></pre>"},{"location":"spec_draft/#event-handlers","title":"Event Handlers","text":"<p>Event handlers define actions triggered by conditions.</p> <pre><code># Define an event handler that runs when a condition is met\n@on(in_zone)\ndef handle_zone_entry():\n    print(\"Sensor entered the zone!\")\n\n# Complex conditions can be used\n@on(is_hot &amp; ~in_zone)\ndef handle_hot_outside_zone():\n    alert(\"Temperature high outside monitored zone\")\n</code></pre>"},{"location":"spec_draft/#runtime","title":"Runtime","text":"<p>The runtime system polls sensors and evaluates conditions.</p> <pre><code># Start the runtime with a polling interval\nstart_blocking(poll_ms=100)  # Blocking call\nawait start_runtime(poll_ms=100)  # Async version\n</code></pre>"},{"location":"spec_draft/#complete-example","title":"Complete Example","text":"<pre><code>from spaxiom import Sensor, Zone, Condition, on, start_blocking\n\n# Define sensors\ntemp_sensor = Sensor(name=\"temp\", sensor_type=\"temperature\", location=(0.0, 0.0, 0.0))\n\n# Define zones\nmonitoring_zone = Zone(0.0, 0.0, 10.0, 10.0)\n\n# Define conditions\nis_hot = Condition(lambda: temp_sensor.read() &gt; 30.0)\nin_zone = Condition(lambda: monitoring_zone.contains(temp_sensor.location))\n\n# Define event handlers\n@on(is_hot &amp; in_zone)\ndef handle_hot_in_zone():\n    print(\"High temperature detected in monitoring zone!\")\n\n# Start the runtime\nstart_blocking(poll_ms=100)\n</code></pre>"},{"location":"spec_draft/#out-of-scope","title":"Out of Scope","text":"<p>The following features are explicitly NOT in scope for the current version:</p> <ul> <li>3D spatial zones (only 2D rectangular zones are supported)</li> <li>Complex geometric shapes (polygons, circles, etc.)</li> <li>Machine learning integrations</li> <li>Distributed sensor networks</li> <li>Real-time guarantees (best-effort only)</li> <li>Persistence layer for sensor data</li> <li>User authentication/authorization</li> <li>Web/mobile interfaces</li> <li>Custom visualization tools</li> <li>External API integrations</li> <li>Time-series forecasting</li> <li>Custom query language </li> </ul>"},{"location":"temporal_and_entities/","title":"Temporal and Entity Operations in Spaxiom","text":"<p>This document explains how to use the temporal (<code>within()</code>), entity (<code>exists()</code>), and privacy operations in Spaxiom DSL.</p>"},{"location":"temporal_and_entities/#temporal-operations","title":"Temporal Operations","text":"<p>The <code>within()</code> function allows you to create conditions that must be true continuously for a specified duration before evaluating to true.</p>"},{"location":"temporal_and_entities/#basic-syntax","title":"Basic Syntax","text":"<pre><code>within(duration_seconds, condition)\n</code></pre>"},{"location":"temporal_and_entities/#parameters","title":"Parameters","text":"<ul> <li><code>duration_seconds</code>: The duration in seconds for which the condition must be continuously true</li> <li><code>condition</code>: The base condition to evaluate over time</li> </ul>"},{"location":"temporal_and_entities/#examples","title":"Examples","text":""},{"location":"temporal_and_entities/#simple-temporal-condition","title":"Simple Temporal Condition","text":"<p>Check if a sensor value has been above a threshold for at least 3 seconds:</p> <pre><code>from spaxiom import Condition, within\nfrom spaxiom.sensor import Sensor\n\n# Create a sensor\ntemp_sensor = Sensor(\"temp1\", \"temperature\", (0, 0, 0))\n\n# Define a basic condition\nhigh_temp = Condition(lambda: temp_sensor.read() &gt; 30.0)\n\n# Create a temporal condition\nhigh_temp_sustained = within(3.0, high_temp)\n\n# This will only evaluate to true if temp_sensor.read() has been\n# continuously &gt; 30.0 for at least 3 seconds\nif high_temp_sustained():\n    print(\"Temperature has been high for at least 3 seconds!\")\n</code></pre>"},{"location":"temporal_and_entities/#using-with-event-handlers","title":"Using with Event Handlers","text":"<p>Register a callback that only fires after a condition has been true for 5 seconds:</p> <pre><code>from spaxiom import Condition, within, on\nfrom spaxiom.sensor import Sensor\n\nmotion_sensor = Sensor(\"motion1\", \"motion\", (0, 0, 0))\n\n# Basic condition: motion detected\nmotion_detected = Condition(lambda: motion_sensor.read() &gt; 0.5)\n\n# Temporal condition: motion sustained for 5 seconds\nsustained_motion = within(5.0, motion_detected)\n\n# This callback will only fire after 5 seconds of continuous motion\n@on(sustained_motion)\ndef handle_sustained_motion():\n    print(\"Sustained motion detected for 5 seconds!\")\n</code></pre>"},{"location":"temporal_and_entities/#entity-operations","title":"Entity Operations","text":"<p>The <code>exists()</code> function allows you to check if any entities in an <code>EntitySet</code> satisfy a given predicate.</p>"},{"location":"temporal_and_entities/#basic-syntax_1","title":"Basic Syntax","text":"<pre><code>exists(entity_set, predicate=None)\n</code></pre>"},{"location":"temporal_and_entities/#parameters_1","title":"Parameters","text":"<ul> <li><code>entity_set</code>: The <code>EntitySet</code> to check</li> <li><code>predicate</code> (optional): A function that takes an entity and returns a boolean. If not provided, the function checks if the entity set has any entities.</li> </ul>"},{"location":"temporal_and_entities/#examples_1","title":"Examples","text":""},{"location":"temporal_and_entities/#simple-existence-check","title":"Simple Existence Check","text":"<p>Check if there are any entities in a set:</p> <pre><code>from spaxiom import EntitySet, Entity, exists, Condition\n\n# Create an entity set\npersons = EntitySet(\"Persons\")\n\n# Check if any persons exist\npersons_exist = exists(persons)\n\n# Use in a condition\nif persons_exist():\n    print(\"At least one person exists in the set\")\n</code></pre>"},{"location":"temporal_and_entities/#filtering-with-predicates","title":"Filtering with Predicates","text":"<p>Check if there are any entities matching a specific criterion:</p> <pre><code>from spaxiom import EntitySet, Entity, exists, Condition\n\n# Create an entity set\nsensors = EntitySet(\"Sensors\")\n\n# Add some entities with attributes\nsensors.add(Entity(attrs={\"type\": \"temperature\", \"value\": 25.0}))\nsensors.add(Entity(attrs={\"type\": \"humidity\", \"value\": 60.0}))\nsensors.add(Entity(attrs={\"type\": \"motion\", \"value\": 0.0}))\n\n# Check if any temperature sensors exceed a threshold\nhigh_temp_exists = exists(sensors, lambda s: s.attrs.get(\"type\") == \"temperature\" and s.attrs.get(\"value\", 0) &gt; 30.0)\n\n# Use in a condition\nif high_temp_exists():\n    print(\"At least one temperature sensor is reading high!\")\n</code></pre>"},{"location":"temporal_and_entities/#combining-with-events","title":"Combining with Events","text":"<p>Using exists() with event handlers:</p> <pre><code>from spaxiom import EntitySet, Entity, exists, on, Condition\n\n# Create an entity set for detected persons\npersons = EntitySet(\"Persons\")\n\n# Create a condition using exists()\nperson_detected = exists(persons, lambda p: p.attrs.get(\"confidence\", 0) &gt; 0.8)\n\n# Register an event handler\n@on(person_detected)\ndef alert_person_detected():\n    print(\"A person with high confidence was detected!\")\n</code></pre>"},{"location":"temporal_and_entities/#combining-temporal-and-entity-operations","title":"Combining Temporal and Entity Operations","text":"<p>You can combine both operations for powerful temporal-entity checking:</p> <pre><code>from spaxiom import EntitySet, Entity, exists, within, on, Condition\n\n# Create an entity set\nvehicles = EntitySet(\"Vehicles\")\n\n# Check if any vehicles exist\nvehicle_exists = exists(vehicles)\n\n# Check if a vehicle has been continuously present for 10 seconds\nvehicle_stopped = within(10.0, vehicle_exists)\n\n# Register an event handler\n@on(vehicle_stopped)\ndef alert_stopped_vehicle():\n    print(\"A vehicle has been stopped for 10 seconds\")\n</code></pre> <p>This will only trigger the alert when a vehicle has been continuously present for 10 seconds.</p>"},{"location":"temporal_and_entities/#privacy-operations","title":"Privacy Operations","text":"<p>Spaxiom supports privacy tags for sensors, allowing you to control how sensitive data is handled in your applications.</p>"},{"location":"temporal_and_entities/#privacy-levels","title":"Privacy Levels","text":"<p>Sensors can be tagged with one of two privacy levels: - <code>\"public\"</code>: Default level, sensor values are displayed normally - <code>\"private\"</code>: Sensitive data, values are redacted in logs and outputs</p>"},{"location":"temporal_and_entities/#basic-syntax_2","title":"Basic Syntax","text":"<p>When creating a sensor, you can specify its privacy level:</p> <pre><code>Sensor(name, sensor_type, location, privacy=\"public\"|\"private\")\n</code></pre>"},{"location":"temporal_and_entities/#examples_2","title":"Examples","text":""},{"location":"temporal_and_entities/#creating-sensors-with-privacy-levels","title":"Creating Sensors with Privacy Levels","text":"<pre><code>from spaxiom import Sensor\n\n# Public sensor (default)\npublic_sensor = Sensor(\"living_room_temp\", \"temperature\", (0, 0, 0))\n\n# Private sensor (explicitly set)\nprivate_sensor = Sensor(\"bedroom_occupancy\", \"presence\", (5, 5, 0), privacy=\"private\")\n</code></pre>"},{"location":"temporal_and_entities/#privacy-inheritance-in-fusion-sensors","title":"Privacy Inheritance in Fusion Sensors","text":"<p>Privacy settings are automatically inherited in fusion sensors. If any component sensor is private, the fusion result is also treated as private:</p> <pre><code>from spaxiom import Sensor, RandomSensor\n\n# Create sensors with different privacy settings\npublic_sensor = RandomSensor(\"public_temperature\", (0, 0, 0))\nprivate_sensor = RandomSensor(\"private_humidity\", (0, 0, 0), privacy=\"private\")\n\n# Public + Public = Public\npublic_fusion = public_sensor.fuse_with(\n    public_sensor,\n    strategy=\"average\",\n    name=\"public_fusion\"\n)\n\n# Public + Private = Private (automatically)\nmixed_fusion = public_sensor.fuse_with(\n    private_sensor,\n    strategy=\"average\",\n    name=\"mixed_fusion\"\n)\n\n# Check privacy levels\nprint(f\"Public fusion privacy: {public_fusion.privacy}\")  # \"public\"\nprint(f\"Mixed fusion privacy: {mixed_fusion.privacy}\")    # \"private\"\n</code></pre>"},{"location":"temporal_and_entities/#runtime-handling-of-private-sensors","title":"Runtime Handling of Private Sensors","text":"<p>The runtime automatically redacts values from private sensors in logs and console output:</p> <pre><code>from spaxiom import RandomSensor, SensorRegistry, Condition, on\nfrom spaxiom.runtime import format_sensor_value\n\n# Create sensors with different privacy levels\npublic_sensor = RandomSensor(\"living_room_temp\", (0, 0, 0))\nprivate_sensor = RandomSensor(\"bedroom_motion\", (5, 0, 0), privacy=\"private\")\n\n# Using the format_sensor_value function respects privacy\npublic_value = public_sensor.read()\nprivate_value = private_sensor.read()\n\nprint(f\"Public sensor value: {format_sensor_value(public_sensor, public_value)}\")   # Shows actual value\nprint(f\"Private sensor value: {format_sensor_value(private_sensor, private_value)}\") # Shows \"***\"\n\n# When using the runtime, private values are automatically redacted\n# and a warning is logged once per run per private sensor\n</code></pre>"},{"location":"temporal_and_entities/#sensorregistry-privacy-methods","title":"SensorRegistry Privacy Methods","text":"<p>You can use <code>SensorRegistry</code> to get sensors based on their privacy level:</p> <pre><code>from spaxiom import SensorRegistry\n\n# Get all sensors\nregistry = SensorRegistry()\nall_sensors = registry.list_all()\n\n# Get only public sensors\npublic_sensors = registry.list_public()\n\n# Get only private sensors\nprivate_sensors = registry.list_private()\n</code></pre>"},{"location":"temporal_and_entities/#real-world-use-case","title":"Real-World Use Case","text":"<p>Here's a more complex example combining multiple conditions:</p> <pre><code>from spaxiom import EntitySet, Entity, Zone, exists, within, on, Condition\n\n# Create zones and entity sets\nrestricted_zone = Zone(0, 0, 10, 10)\npersons = EntitySet(\"Persons\")\nvehicles = EntitySet(\"Vehicles\")\n\n# Define conditions\nperson_in_zone = exists(persons, lambda p: restricted_zone.contains((p.attrs.get(\"x\", 0), p.attrs.get(\"y\", 0))))\nvehicle_in_zone = exists(vehicles, lambda v: restricted_zone.contains((v.attrs.get(\"x\", 0), v.attrs.get(\"y\", 0))))\n\n# Create a combined condition\nintrusion = person_in_zone &amp; vehicle_in_zone\n\n# Create a temporal condition\nsustained_intrusion = within(30.0, intrusion)\n\n# Register an event handler\n@on(sustained_intrusion)\ndef security_alert():\n    print(\"ALERT: Person and vehicle in restricted zone for 30 seconds!\")\n</code></pre> <p>This example demonstrates a security system that alerts when both a person and a vehicle have been detected in a restricted zone for at least 30 seconds. </p>"},{"location":"temporal_and_entities/#privacy-aware-real-world-example","title":"Privacy-Aware Real-World Example","text":"<p>Here's an example of a smart home system that respects privacy:</p> <pre><code>from spaxiom import Sensor, Zone, Condition, on, within, SensorRegistry\nfrom spaxiom.runtime import format_sensor_value\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\n\n# Create zones for different areas\nliving_room = Zone(0, 0, 5, 5)\nbedroom = Zone(6, 0, 10, 5)\nbathroom = Zone(6, 6, 10, 10)\n\n# Create sensors with appropriate privacy levels\nliving_room_temp = Sensor(\"living_temp\", \"temperature\", (2.5, 2.5, 0))  # public by default\nbedroom_motion = Sensor(\"bedroom_motion\", \"motion\", (8, 2.5, 0), privacy=\"private\")\nbathroom_presence = Sensor(\"bathroom_presence\", \"presence\", (8, 8, 0), privacy=\"private\")\n\n# Define conditions\nhigh_temp = Condition(lambda: living_room_temp.read() &gt; 25.0)\nbedroom_movement = Condition(lambda: bedroom_motion.read() &gt; 0.5)\nbathroom_occupied = Condition(lambda: bathroom_presence.read() &gt; 0.5)\n\n# Create temporal conditions\nsustained_high_temp = within(60.0, high_temp)\nsustained_bedroom_motion = within(5.0, bedroom_movement)\nsustained_bathroom_presence = within(2.0, bathroom_occupied)\n\n# Register event handlers\n@on(sustained_high_temp)\ndef adjust_temperature():\n    temp = living_room_temp.read()\n    # Public sensor, so we can log the actual value\n    logging.info(f\"Adjusting temperature - current value: {temp}\u00b0C\")\n    # Set up temperature adjustment...\n\n@on(sustained_bedroom_motion)\ndef bedroom_occupied():\n    # Private sensor, so we respect privacy in our logs\n    value = bedroom_motion.read()\n    formatted = format_sensor_value(bedroom_motion, value)\n    logging.info(f\"Bedroom motion detected: {formatted}\")\n    # Adjust bedroom settings...\n\n@on(sustained_bathroom_presence)\ndef bathroom_occupied():\n    # Private sensor, so we respect privacy in our logs\n    value = bathroom_presence.read()\n    formatted = format_sensor_value(bathroom_presence, value)\n    logging.info(f\"Bathroom presence detected: {formatted}\")\n    # Turn on fan and lights...\n\n# Start the runtime\nfrom spaxiom.runtime import start_blocking\nstart_blocking()\n</code></pre> <p>This example showcases a privacy-aware smart home system where: 1. Public environmental sensors (like temperature) show their actual values 2. Private occupancy sensors (in bedrooms and bathrooms) have their values redacted in logs 3. The system still functions correctly with all sensors, but respects privacy in its outputs </p>"},{"location":"whats_new/","title":"What's New in Spaxiom 0.1.0","text":"<p>We're excited to announce the first beta release of Spaxiom 0.1.0! This release includes several major features that greatly enhance the capabilities of the Spaxiom DSL.</p>"},{"location":"whats_new/#onnx-inference","title":"ONNX Inference","text":"<p>Spaxiom now supports AI model inference using ONNX Runtime, allowing you to integrate machine learning models with your sensor network:</p> <ul> <li>Run real-time object detection directly within your Spaxiom applications</li> <li>Generate entities automatically from detection results</li> <li>Integrate with spatial and temporal reasoning</li> </ul> <pre><code>from spaxiom.ai import ONNXDetector\nfrom spaxiom import on, exists\n\n# Initialize ONNX-based person detector\ndetector = ONNXDetector(\n    model_path=\"models/person_detector.onnx\",\n    input_name=\"image\",\n    output_name=\"detection\",\n    confidence_threshold=0.5\n)\n\n# Create an entity set to store detected persons\npersons = EntitySet(\"Persons\")\n\n# Define condition based on entity detection\nperson_detected = exists(persons, lambda p: p.attrs.get(\"confidence\", 0) &gt; 0.7)\n\n# Register an event handler\n@on(person_detected)\ndef alert_person_detected():\n    print(\"Person detected with high confidence!\")\n</code></pre> <p>See the ONNX Person Detection example for a complete implementation.</p>"},{"location":"whats_new/#gpio-hardware-integration","title":"GPIO Hardware Integration","text":"<p>Connect your Spaxiom applications to the physical world with our new GPIO adapters for Raspberry Pi and similar devices:</p> <ul> <li>Read sensor data from digital pins using <code>GPIOSensor</code></li> <li>Control output devices with <code>GPIOOutput</code></li> <li>Compatible with both RPi.GPIO and gpiozero libraries</li> </ul> <pre><code>from spaxiom.gpio import GPIOSensor, GPIOOutput\nfrom spaxiom import on, Condition, within\n\n# Create a door sensor on GPIO pin 17\ndoor_sensor = GPIOSensor(\n    name=\"front_door\",\n    pin=17,\n    sensor_type=\"door\",\n    pull_up=True,\n    active_low=True\n)\n\n# Create an LED output on GPIO pin 18\nled = GPIOOutput(\n    name=\"alert_light\",\n    pin=18\n)\n\n# Define condition and register handler\ndoor_open = Condition(lambda: door_sensor.read() == 1)\ndoor_open_long = within(30.0, door_open)\n\n@on(door_open_long)\ndef alert_door_left_open():\n    print(\"Door has been open for 30 seconds!\")\n    led.write(1)  # Turn on the LED\n</code></pre>"},{"location":"whats_new/#privacy-controls","title":"Privacy Controls","text":"<p>Enhance data protection and privacy with our new privacy tagging system:</p> <ul> <li>Mark sensors as private to control data visibility</li> <li>Automatic redaction of private sensor values in logs</li> <li>Privacy warnings when accessing restricted data</li> </ul> <pre><code>from spaxiom import Sensor\n\n# Create a sensor with privacy settings\ntemperature = Sensor(\n    name=\"bedroom_temp\",\n    sensor_type=\"temperature\",\n    location=(10, 12, 0),\n    privacy=\"private\"  # Mark this sensor as private\n)\n\n# Private values will be redacted in logs and outputs\n</code></pre>"},{"location":"whats_new/#statistical-analysis","title":"Statistical Analysis","text":"<p>Perform statistical analysis on sensor data streams with the new summarization capabilities:</p> <ul> <li>Call <code>summary()</code> on Condition instances to get a RollingSummary object</li> <li>Track statistics like min, max, mean, and variance</li> <li>Monitor trends and patterns over time</li> </ul> <pre><code>from spaxiom import Sensor, Condition\n\n# Create a temperature sensor\ntemp_sensor = Sensor(\"room_temp\", \"temperature\", (0, 0, 0))\n\n# Create a condition that reads the temperature\ntemp_reading = Condition(lambda: temp_sensor.read())\n\n# Get a summary object for statistical analysis\ntemp_stats = temp_reading.summary(window_size=100)\n\n# In your event handler or elsewhere:\ndef print_stats():\n    print(f\"Min: {temp_stats.min():.1f}\u00b0C\")\n    print(f\"Max: {temp_stats.max():.1f}\u00b0C\")\n    print(f\"Mean: {temp_stats.mean():.1f}\u00b0C\")\n    print(f\"Variance: {temp_stats.variance():.2f}\")\n</code></pre>"},{"location":"whats_new/#cli-scaffold-tool","title":"CLI Scaffold Tool","text":"<p>Quickly start new projects with the CLI scaffolding tool:</p> <ul> <li>Generate script templates with <code>spax-run new</code></li> <li>Customize the number of sensors and zones</li> <li>Configure privacy settings</li> <li>Get a ready-to-run application structure</li> </ul> <pre><code># Create a basic demo\nspax-run new my_app\n\n# Customize with more sensors and zones\nspax-run new complex_app --sensors 5 --zones 3 \n\n# Disable privacy features\nspax-run new simple_app --no-privacy\n</code></pre>"},{"location":"whats_new/#cli-improvements","title":"CLI Improvements","text":"<ul> <li>Added <code>--verbose</code> flag to enable detailed runtime logging:</li> </ul> <pre><code># Run with verbose logging for troubleshooting\nspax-run run my_app.py --verbose\n</code></pre> <p>The verbose mode provides detailed information about sensor readings, condition evaluations, plugin loading, and internal runtime events, making it easier to debug complex applications.</p>"},{"location":"whats_new/#other-improvements","title":"Other Improvements","text":"<ul> <li>Enhanced error handling across all modules</li> <li>More comprehensive test coverage (over 60%)</li> <li>Updated documentation with privacy and hardware examples</li> <li>Various bug fixes and performance improvements</li> </ul>"},{"location":"whats_new/#getting-started-with-010","title":"Getting Started with 0.1.0","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade spaxiom\n</code></pre> <p>For new installations:</p> <pre><code>pip install spaxiom\n</code></pre> <p>Check out the Quick Start Guide to begin using these new features! </p>"},{"location":"api/overview/","title":"API Overview","text":"<p>Spaxiom DSL provides a comprehensive API for working with spatial sensor fusion, temporal reasoning, and event detection. This section documents the core components of the API.</p>"},{"location":"api/overview/#core-components","title":"Core Components","text":""},{"location":"api/overview/#sensors","title":"Sensors","text":"<p>The <code>Sensor</code> class is the foundation for all data acquisition in Spaxiom. Sensors provide readings from the physical or virtual world that can be processed and analyzed.</p> <pre><code>from spaxiom import Sensor\n\n# Create a sensor\ntemp_sensor = Sensor(\"temp1\", \"temperature\", (0, 0, 0))\n\n# Read a value from the sensor\nvalue = temp_sensor.read()\n</code></pre>"},{"location":"api/overview/#zones","title":"Zones","text":"<p>The <code>Zone</code> class defines spatial regions that can contain sensors, entities, or other objects. Zones are used for spatial reasoning and containment checks.</p> <pre><code>from spaxiom import Zone\n\n# Define a rectangular zone\noffice_zone = Zone(0, 0, 10, 10)\n\n# Check if a point is in the zone\nis_in_zone = office_zone.contains((5, 5))\n</code></pre>"},{"location":"api/overview/#conditions","title":"Conditions","text":"<p>The <code>Condition</code> class wraps boolean functions that can be combined with logical operators to create complex conditions for event triggering.</p> <pre><code>from spaxiom import Condition\n\n# Create a condition\nis_hot = Condition(lambda: temp_sensor.read() &gt; 30.0)\n\n# Combine conditions\nis_occupied = Condition(lambda: motion_sensor.read() &gt; 0.5)\nhot_and_occupied = is_hot &amp; is_occupied\n</code></pre>"},{"location":"api/overview/#events","title":"Events","text":"<p>The <code>on</code> decorator registers callbacks that are triggered when specific conditions are met.</p> <pre><code>from spaxiom import on\n\n@on(hot_and_occupied)\ndef alert_hot_and_occupied():\n    print(\"Room is hot and occupied!\")\n</code></pre>"},{"location":"api/overview/#entities","title":"Entities","text":"<p>The <code>Entity</code> and <code>EntitySet</code> classes provide a way to track and query collections of objects with arbitrary attributes.</p> <pre><code>from spaxiom import Entity, EntitySet\n\n# Create a collection of entities\npersons = EntitySet(\"Persons\")\n\n# Add an entity\npersons.add(Entity(attrs={\"type\": \"person\", \"name\": \"Alice\"}))\n\n# Query entities\nfor person in persons:\n    print(person.attrs.get(\"name\"))\n</code></pre>"},{"location":"api/overview/#fusion","title":"Fusion","text":"<p>The <code>WeightedFusion</code> class allows combining multiple sensor inputs with specified weights to create derived sensors.</p> <pre><code>from spaxiom import WeightedFusion\n\n# Create a fusion sensor\ncomfort_index = WeightedFusion(\n    name=\"comfort\",\n    sensors=[temp_sensor, humidity_sensor],\n    weights=[0.6, 0.4],\n    location=(0, 0, 0)\n)\n\n# Read the fused value\ncomfort = comfort_index.read()\n</code></pre>"},{"location":"api/overview/#utility-functions","title":"Utility Functions","text":"<p>In addition to the core classes, Spaxiom provides several utility functions for temporal reasoning and other operations:</p> <ul> <li><code>within(seconds, condition)</code>: Creates a temporal condition that must be true for a specific duration</li> <li><code>sequence(*conditions, within_s=seconds)</code>: Detects ordered sequences of events within a time window</li> <li><code>exists(entity_set, predicate)</code>: Checks if entities matching a predicate exist in an entity set</li> <li><code>transitioned_to_true(condition)</code>: Detects when a condition transitions from false to true</li> </ul> <p>These functions are documented in detail in their respective sections. </p>"},{"location":"examples/overview/","title":"Examples Overview","text":"<p>Spaxiom comes with a variety of examples that demonstrate its capabilities and provide starting points for your own applications. Below is a summary of the available examples.</p>"},{"location":"examples/overview/#smart-building-example","title":"Smart Building Example","text":"<p>The Smart Building example demonstrates how to use Spaxiom for building automation and occupancy detection:</p> <ul> <li>Reading historical sensor data from CSV files</li> <li>Defining multiple zones (office area, meeting room)</li> <li>Detecting occupancy using pressure and thermal sensors</li> <li>Creating a comfort index by fusing sensor data with custom weights</li> <li>Logging occupancy events in real-time</li> </ul> <pre><code># Define occupancy conditions\npressure_a_active = Condition(lambda: pressure_a.read() &gt; 0.5)\nthermal_a_active = Condition(lambda: thermal_a.read() &gt; 22.0)\nperson_in_a = pressure_a_active &amp; thermal_a_active\n\n# Add temporal constraint - must be true for 3 seconds\nsustained_presence_a = within(3.0, person_in_a)\n\n# Register callback for occupancy events\n@on(sustained_presence_a)\ndef notify_zone_a_occupied():\n    comfort = comfort_a.read()\n    logger.info(f\"ZONE A OCCUPIED - Comfort Index: {comfort:.2f}\")\n</code></pre>"},{"location":"examples/overview/#sensor-fusion-example","title":"Sensor Fusion Example","text":"<p>Sensor fusion allows combining multiple sensor inputs:</p> <ul> <li>Creating different types of sensors (pressure, thermal, motion)</li> <li>Combining sensor outputs using various fusion strategies</li> <li>Using weighted averages for data fusion</li> <li>Creating derived sensors with custom transformations</li> </ul> <pre><code># Create fusion sensor with custom weights\nfusion_sensor = WeightedFusion(\n    name=\"fusion_sensor\",\n    sensors=[pressure_sensor, thermal_sensor],\n    weights=[0.7, 0.3],\n    location=(0, 0, 0)\n)\n\n# Read the fused value\nfused_value = fusion_sensor.read()\n</code></pre>"},{"location":"examples/overview/#temporal-sequences-example","title":"Temporal Sequences Example","text":"<p>Temporal sequences allow detecting ordered events:</p> <ul> <li>Creating event sensors for different steps in a sequence</li> <li>Defining a temporal sequence pattern with the <code>sequence()</code> function</li> <li>Adding time constraints with the <code>within_s</code> parameter</li> <li>Triggering callbacks when sequences are detected</li> </ul> <pre><code># Create a sequence pattern\nentry_sequence = sequence(\n    motion_outside_detected,\n    door_opened,\n    motion_inside_detected,\n    lights_on,\n    within_s=15.0\n)\n\n# Register callback for the sequence\n@on(entry_sequence)\ndef welcome_home():\n    print(\"Welcome home sequence detected!\")\n</code></pre>"},{"location":"examples/overview/#running-the-examples","title":"Running the Examples","text":"<p>To run any of the examples, use the following command from the project root directory:</p> <pre><code>python examples/example_name.py\n</code></pre> <p>For example:</p> <pre><code>python examples/smart_building.py\n</code></pre> <p>You can modify the examples to experiment with different parameters, conditions, and callback functions to suit your specific use case. </p>"},{"location":"examples/smart_building/","title":"Smart Building Example","text":"<p>The Smart Building example demonstrates how to use Spaxiom for building automation and occupancy detection. This example shows:</p> <ol> <li>Reading historical sensor data from CSV files</li> <li>Defining spatial zones for different building areas</li> <li>Creating occupancy conditions using pressure and thermal sensors</li> <li>Fusing sensor data with custom weights into a comfort index</li> <li>Logging occupancy events at regular intervals</li> </ol>"},{"location":"examples/smart_building/#overview","title":"Overview","text":"<p>The example sets up two zones (an office area and a meeting room), each with pressure and thermal sensors. It then creates a comfort index by fusing the thermal and pressure data with weights of 60% and 40% respectively. The system detects when a person is present in either zone based on the combined conditions and logs the comfort level.</p>"},{"location":"examples/smart_building/#full-example-code","title":"Full Example Code","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSmart Building Demo for Spaxiom DSL.\n\nThis example demonstrates:\n1. Using FileSensors to read historical CSV data (floor pressure and thermal)\n2. Defining spatial zones and occupancy conditions\n3. Fusing sensors with custom weights to create a comfort index\n4. Logging occupancy levels at regular intervals\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport random\nimport logging\nfrom datetime import datetime\n\n# Add the parent directory to the Python path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\nfrom spaxiom import Zone, Condition, on, within, Sensor\nfrom spaxiom.adaptors.file_sensor import FileSensor\nfrom spaxiom.fusion import WeightedFusion\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\nlogger = logging.getLogger(\"SmartBuilding\")\n\n# A simple adaptor that generates mock values if the file doesn't exist\nclass SmartSensor(Sensor):\n    \"\"\"\n    A sensor that either reads from a CSV file if it exists,\n    or generates random values within a specified range.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        sensor_type: str,\n        location: tuple,\n        file_path: str = None,\n        min_value: float = 0.0,\n        max_value: float = 1.0,\n    ):\n        super().__init__(name=name, sensor_type=sensor_type, location=location)\n        self.file_path = file_path\n        self.min_value = min_value\n        self.max_value = max_value\n        self.file_sensor = None\n\n        # Try to create a file sensor if the path exists\n        if file_path and os.path.exists(file_path):\n            try:\n                # Determine which column to use based on sensor type\n                column_name = \"pressure\" if sensor_type == \"pressure\" else \"temperature\"\n                self.file_sensor = FileSensor(\n                    name=f\"file_{name}\",\n                    file_path=file_path,\n                    column_name=column_name,\n                    location=location,\n                    loop=True,  # Loop through the file data\n                )\n                print(f\"  - Using CSV data from {os.path.basename(file_path)}\")\n            except Exception as e:\n                print(f\"  - Error loading file sensor: {e}\")\n                self.file_sensor = None\n\n    def _read_raw(self):\n        \"\"\"Read from file sensor if available, otherwise generate random value\"\"\"\n        if self.file_sensor:\n            value = self.file_sensor._read_raw()\n            if value is not None:\n                return value\n\n        # Generate random value if file sensor not available or returned None\n        return self.min_value + random.random() * (self.max_value - self.min_value)\n\ndef main():\n    \"\"\"Run the smart building demo with historical sensor data.\"\"\"\n    print(\"\\nSpaxiom Smart Building Demo\")\n    print(\"===========================\")\n    print(\"This demo demonstrates:\")\n    print(\"1. Reading historical sensor data from CSV files\")\n    print(\"2. Detecting occupancy in different building zones\")\n    print(\"3. Creating a weighted comfort index from thermal and pressure data\")\n    print(\"4. Logging occupancy information at regular intervals\\n\")\n\n    # Define zones (in square meters)\n    zone_a = Zone(0, 0, 10, 10)  # 10x10m zone (e.g., office area)\n    zone_b = Zone(15, 0, 25, 10)  # 10x10m zone (e.g., meeting room)\n\n    print(f\"Zone A: {zone_a} (Office Area)\")\n    print(f\"Zone B: {zone_b} (Meeting Room)\\n\")\n\n    # Create paths to CSV files (these would contain timestamp + value pairs)\n    # Note: These files don't need to exist for the demo - SmartSensor will generate random data\n    pressure_a_path = os.path.join(os.path.dirname(__file__), \"data/pressure_a.csv\")\n    thermal_a_path = os.path.join(os.path.dirname(__file__), \"data/thermal_a.csv\")\n    pressure_b_path = os.path.join(os.path.dirname(__file__), \"data/pressure_b.csv\")\n    thermal_b_path = os.path.join(os.path.dirname(__file__), \"data/thermal_b.csv\")\n\n    # Ensure data directory exists\n    data_dir = os.path.join(os.path.dirname(__file__), \"data\")\n    os.makedirs(data_dir, exist_ok=True)\n\n    print(\"Initializing sensors...\")\n\n    # Create sensors for each data source\n    # If files don't exist, random values will be generated\n    pressure_a = SmartSensor(\n        name=\"pressure_A\",\n        sensor_type=\"pressure\",\n        location=(5, 5, 0),  # Center of Zone A\n        file_path=pressure_a_path,\n        min_value=0.0,  # Random values between 0-1 if file not found\n        max_value=1.0,\n    )\n\n    thermal_a = SmartSensor(\n        name=\"thermal_A\",\n        sensor_type=\"thermal\",\n        location=(5, 5, 0),  # Center of Zone A\n        file_path=thermal_a_path,\n        min_value=15.0,  # Random temperatures between 15-30\u00b0C if file not found\n        max_value=30.0,\n    )\n\n    pressure_b = SmartSensor(\n        name=\"pressure_B\",\n        sensor_type=\"pressure\",\n        location=(20, 5, 0),  # Center of Zone B\n        file_path=pressure_b_path,\n        min_value=0.0,\n        max_value=1.0,\n    )\n\n    thermal_b = SmartSensor(\n        name=\"thermal_B\",\n        sensor_type=\"thermal\",\n        location=(20, 5, 0),  # Center of Zone B\n        file_path=thermal_b_path,\n        min_value=15.0,\n        max_value=30.0,\n    )\n\n    print(\"Sensors initialized:\")\n    print(f\"  {pressure_a}\")\n    print(f\"  {thermal_a}\")\n    print(f\"  {pressure_b}\")\n    print(f\"  {thermal_b}\\n\")\n\n    # Create weighted fusion sensors for comfort index\n    # Comfort index is 60% thermal + 40% pressure (normalized)\n    comfort_a = WeightedFusion(\n        name=\"comfort_A\",\n        sensors=[thermal_a, pressure_a],\n        weights=[0.6, 0.4],\n        location=(5, 5, 0),\n    )\n\n    comfort_b = WeightedFusion(\n        name=\"comfort_B\",\n        sensors=[thermal_b, pressure_b],\n        weights=[0.6, 0.4],\n        location=(20, 5, 0),\n    )\n\n    print(\"Fusion sensors created:\")\n    print(f\"  {comfort_a} (60% thermal, 40% pressure)\")\n    print(f\"  {comfort_b} (60% thermal, 40% pressure)\\n\")\n\n    # Define conditions for occupancy detection\n    # Person in Zone A = pressure_a &gt; 0.5 AND thermal_a &gt; 22\u00b0C\n    pressure_a_active = Condition(lambda: pressure_a.read() &gt; 0.5)\n    thermal_a_active = Condition(lambda: thermal_a.read() &gt; 22.0)\n    person_in_a = pressure_a_active &amp; thermal_a_active\n\n    # Person in Zone B = pressure_b &gt; 0.5 AND thermal_b &gt; 22\u00b0C\n    pressure_b_active = Condition(lambda: pressure_b.read() &gt; 0.5)\n    thermal_b_active = Condition(lambda: thermal_b.read() &gt; 22.0)\n    person_in_b = pressure_b_active &amp; thermal_b_active\n\n    # Sustained presence (for 3 seconds) to avoid false positives\n    sustained_presence_a = within(3.0, person_in_a)\n    sustained_presence_b = within(3.0, person_in_b)\n\n    # Register callbacks for occupancy events\n    @on(sustained_presence_a)\n    def notify_zone_a_occupied():\n        comfort = comfort_a.read()\n        logger.info(f\"ZONE A OCCUPIED - Comfort Index: {comfort:.2f}\")\n\n    @on(sustained_presence_b)\n    def notify_zone_b_occupied():\n        comfort = comfort_b.read()\n        logger.info(f\"ZONE B OCCUPIED - Comfort Index: {comfort:.2f}\")\n\n    print(\"Starting monitoring...\")\n    print(\"Press Ctrl+C to exit\\n\")\n\n    # Start the event loop with manual condition checking\n    try:\n        while True:\n            # Read current sensor values\n            p_a = pressure_a.read() \n            t_a = thermal_a.read()\n            c_a = comfort_a.read()\n\n            p_b = pressure_b.read()\n            t_b = thermal_b.read()\n            c_b = comfort_b.read()\n\n            # Current timestamp\n            now = datetime.now().strftime(\"%H:%M:%S\")\n\n            # Log occupancy level every second\n            print(f\"[{now}] ZONE A: Pressure: {p_a:.2f}, Temp: {t_a:.1f}\u00b0C, Comfort: {c_a:.2f}\", end=\"\")\n            print(f\" | ZONE B: Pressure: {p_b:.2f}, Temp: {t_b:.1f}\u00b0C, Comfort: {c_b:.2f}\", end=\"\\r\")\n\n            # Process events\n            from spaxiom.events import process_events\n            process_events()\n\n            # Wait before next update\n            time.sleep(1.0)\n\n    except KeyboardInterrupt:\n        print(\"\\n\\nSmart Building Demo stopped by user.\")\n\n    # Print summary\n    print(\"\\nDemo Summary:\")\n    print(\"=============\")\n    print(f\"Zone A final readings - Pressure: {pressure_a.read():.2f}, Temperature: {thermal_a.read():.1f}\u00b0C\")\n    print(f\"Zone B final readings - Pressure: {pressure_b.read():.2f}, Temperature: {thermal_b.read():.1f}\u00b0C\")\n    print(f\"Comfort A: {comfort_a.read():.2f}, Comfort B: {comfort_b.read():.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/smart_building/#key-components","title":"Key Components","text":""},{"location":"examples/smart_building/#smartsensor-class","title":"SmartSensor Class","text":"<p>The <code>SmartSensor</code> class is a custom sensor implementation that attempts to read data from CSV files if they exist, or falls back to generating random values within a specified range if they don't. This provides flexibility and ensures the example always works.</p> <pre><code>class SmartSensor(Sensor):\n    \"\"\"\n    A sensor that either reads from a CSV file if it exists,\n    or generates random values within a specified range.\n    \"\"\"\n    # ...implementation...\n</code></pre>"},{"location":"examples/smart_building/#spatial-zones","title":"Spatial Zones","text":"<p>Two distinct zones are defined to represent different areas of the building:</p> <pre><code># Define zones (in square meters)\nzone_a = Zone(0, 0, 10, 10)  # 10x10m zone (e.g., office area)\nzone_b = Zone(15, 0, 25, 10)  # 10x10m zone (e.g., meeting room)\n</code></pre>"},{"location":"examples/smart_building/#occupancy-conditions","title":"Occupancy Conditions","text":"<p>Occupancy conditions are created by combining pressure and thermal sensor readings:</p> <pre><code># Person in Zone A = pressure_a &gt; 0.5 AND thermal_a &gt; 22\u00b0C\npressure_a_active = Condition(lambda: pressure_a.read() &gt; 0.5)\nthermal_a_active = Condition(lambda: thermal_a.read() &gt; 22.0)\nperson_in_a = pressure_a_active &amp; thermal_a_active\n</code></pre>"},{"location":"examples/smart_building/#sensor-fusion","title":"Sensor Fusion","text":"<p>Sensors are fused with custom weights to create a comfort index:</p> <pre><code># Comfort index is 60% thermal + 40% pressure (normalized)\ncomfort_a = WeightedFusion(\n    name=\"comfort_A\",\n    sensors=[thermal_a, pressure_a],\n    weights=[0.6, 0.4],\n    location=(5, 5, 0),\n)\n</code></pre>"},{"location":"examples/smart_building/#temporal-conditions","title":"Temporal Conditions","text":"<p>Occupancy conditions are sustained for a minimum period to avoid false positives:</p> <pre><code># Sustained presence (for 3 seconds) to avoid false positives\nsustained_presence_a = within(3.0, person_in_a)\n</code></pre>"},{"location":"examples/smart_building/#event-registration","title":"Event Registration","text":"<p>Callbacks are registered to respond to occupancy events:</p> <pre><code>@on(sustained_presence_a)\ndef notify_zone_a_occupied():\n    comfort = comfort_a.read()\n    logger.info(f\"ZONE A OCCUPIED - Comfort Index: {comfort:.2f}\")\n</code></pre>"},{"location":"examples/smart_building/#running-the-example","title":"Running the Example","text":"<p>To run this example, use:</p> <pre><code>python examples/smart_building.py\n</code></pre>"},{"location":"examples/smart_building/#sample-csv-data","title":"Sample CSV Data","text":"<p>The example includes sample CSV data files for the pressure and thermal sensors. Here's an example of the data format:</p> <p>pressure_a.csv: <pre><code>timestamp,pressure\n2023-11-01 08:00:00,0.1\n2023-11-01 08:01:00,0.2\n2023-11-01 08:02:00,0.3\n# ... more entries ...\n</code></pre></p> <p>thermal_a.csv: <pre><code>timestamp,temperature\n2023-11-01 08:00:00,19.5\n2023-11-01 08:01:00,20.2\n2023-11-01 08:02:00,21.0\n# ... more entries ...\n</code></pre></p>"},{"location":"examples/smart_building/#extending-the-example","title":"Extending the Example","text":"<p>You can extend this example in several ways:</p> <ol> <li>Add more sensor types (humidity, light, air quality)</li> <li>Create more complex conditions for different scenarios</li> <li>Implement automated controls based on occupancy (e.g., adjusting HVAC)</li> <li>Add historical data analysis and pattern recognition</li> <li>Connect to real IoT sensors instead of CSV files</li> </ol> <p>This example showcases the flexibility and power of Spaxiom for building automation and IoT applications. </p>"}]}